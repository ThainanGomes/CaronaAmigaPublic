"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 * @format
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.installScriptsAndDependencies = exports.copyProjectTemplateAndReplace = void 0;
const chalk = require("chalk");
const path = require("path");
const username = require("username");
const uuid = require("uuid");
const childProcess = require("child_process");
const fs = require("fs");
const os = require("os");
const semver = require("semver");
const _ = require("lodash");
const findUp = require("find-up");
const configUtils_1 = require("../config/configUtils");
const generator_common_1 = require("../generator-common");
const package_utils_1 = require("@react-native-windows/package-utils");
const windowsDir = 'windows';
const bundleDir = 'Bundle';
async function generateCertificate(srcPath, destPath, newProjectName, currentUser) {
    console.log('Generating self-signed certificate...');
    if (os.platform() === 'win32') {
        try {
            const timeout = 10000; // 10 seconds;
            const thumbprint = childProcess
                .execSync(`powershell -NoProfile -Command "Write-Output (New-SelfSignedCertificate -KeyUsage DigitalSignature -KeyExportPolicy Exportable -Subject 'CN=${currentUser}' -TextExtension @('2.5.29.37={text}1.3.6.1.5.5.7.3.3', '2.5.29.19={text}Subject Type:End Entity') -CertStoreLocation 'Cert:\\CurrentUser\\My').Thumbprint"`, { timeout })
                .toString()
                .trim();
            if (!fs.existsSync(path.join(windowsDir, newProjectName))) {
                fs.mkdirSync(path.join(windowsDir, newProjectName));
            }
            childProcess.execSync(`powershell -NoProfile -Command "$pwd = (ConvertTo-SecureString -String password -Force -AsPlainText); Export-PfxCertificate -Cert 'cert:\\CurrentUser\\My\\${thumbprint}' -FilePath ${path.join(windowsDir, newProjectName, newProjectName)}_TemporaryKey.pfx -Password $pwd"`, { timeout });
            console.log(chalk.green('Self-signed certificate generated successfully.'));
            return thumbprint;
        }
        catch (err) {
            console.log(chalk.yellow('Failed to generate Self-signed certificate.'));
        }
    }
    console.log(chalk.yellow('Using Default Certificate. Use Visual Studio to renew it.'));
    await generator_common_1.copyAndReplaceWithChangedCallback(path.join(srcPath, 'keys', 'MyApp_TemporaryKey.pfx'), destPath, path.join(windowsDir, newProjectName, newProjectName + '_TemporaryKey.pfx'));
    return null;
}
function pascalCase(str) {
    const camelCase = _.camelCase(str);
    return camelCase[0].toUpperCase() + camelCase.substr(1);
}
// Existing high cyclomatic complexity
// eslint-disable-next-line complexity
async function copyProjectTemplateAndReplace(srcRootPath, destPath, newProjectName, namespace, options) {
    if (!srcRootPath) {
        throw new Error('Need a path to copy from');
    }
    if (!destPath) {
        throw new Error('Need a path to copy to');
    }
    if (!newProjectName) {
        throw new Error('Need a project name');
    }
    const projectType = options.projectType;
    // React-native init only allows alphanumerics in project names, but other
    // new project tools (like create-react-native-module) are less strict.
    if (projectType === 'lib') {
        newProjectName = pascalCase(newProjectName);
    }
    // Similar to the above, but we want to retain namespace separators
    if (projectType === 'lib') {
        namespace = namespace
            .split(/[.:]+/)
            .map(pascalCase)
            .join('.');
    }
    generator_common_1.createDir(path.join(destPath, windowsDir));
    generator_common_1.createDir(path.join(destPath, windowsDir, newProjectName));
    if (projectType === 'app') {
        generator_common_1.createDir(path.join(destPath, windowsDir, newProjectName, bundleDir));
        generator_common_1.createDir(path.join(destPath, windowsDir, newProjectName, 'BundleBuilder'));
    }
    const language = options.language;
    const namespaceCpp = toCppNamespace(namespace);
    if (options.experimentalNuGetDependency) {
        console.log('Using experimental NuGet dependency.');
    }
    if (options.useWinUI3) {
        console.log('Using experimental WinUI3 dependency.');
    }
    const projDir = 'proj';
    const srcPath = path.join(srcRootPath, `${language}-${projectType}`);
    const sharedPath = path.join(srcRootPath, `shared-${projectType}`);
    const projectGuid = uuid.v4();
    const rnwVersion = require('react-native-windows/package.json').version;
    const nugetVersion = options.nuGetTestVersion || rnwVersion;
    const packageGuid = uuid.v4();
    const currentUser = username.sync(); // Gets the current username depending on the platform.
    let mainComponentName = newProjectName;
    const appJsonPath = await findUp('app.json', { cwd: destPath });
    if (appJsonPath) {
        mainComponentName = JSON.parse(fs.readFileSync(appJsonPath, 'utf8')).name;
    }
    const certificateThumbprint = projectType === 'app'
        ? await generateCertificate(srcPath, destPath, newProjectName, currentUser)
        : null;
    const xamlNamespace = options.useWinUI3
        ? 'Microsoft.UI.Xaml'
        : 'Windows.UI.Xaml';
    const xamlNamespaceCpp = toCppNamespace(xamlNamespace);
    const winui3PropsPath = require.resolve('react-native-windows/PropertySheets/WinUI.props', { paths: [process.cwd()] });
    const winui3Props = configUtils_1.readProjectFile(winui3PropsPath);
    const winui3Version = configUtils_1.findPropertyValue(winui3Props, 'WinUI3Version', winui3PropsPath);
    const csNugetPackages = [
        {
            id: 'Microsoft.NETCore.UniversalWindowsPlatform',
            version: '6.2.9',
        },
    ];
    const cppNugetPackages = [
        {
            id: 'Microsoft.Windows.CppWinRT',
            version: '2.0.210312.4',
            propsTopOfFile: true,
            hasProps: true,
            hasTargets: true,
        },
        {
            id: options.useWinUI3 ? 'Microsoft.WinUI' : 'Microsoft.UI.Xaml',
            version: options.useWinUI3 ? winui3Version : '2.3.191129002',
            hasProps: false,
            hasTargets: false,
        },
    ];
    if (options.experimentalNuGetDependency) {
        csNugetPackages.push({
            id: 'Microsoft.ReactNative.Managed',
            version: nugetVersion,
        });
        cppNugetPackages.push({
            id: 'Microsoft.ReactNative',
            version: nugetVersion,
            hasProps: false,
            hasTargets: true,
        });
        cppNugetPackages.push({
            id: 'Microsoft.ReactNative.Cxx',
            version: nugetVersion,
            hasProps: false,
            hasTargets: true,
        });
    }
    if (options.useHermes) {
        cppNugetPackages.push({
            id: 'ReactNative.Hermes.Windows',
            version: '0.7.2',
            hasProps: false,
            hasTargets: true,
        });
    }
    const templateVars = {
        useMustache: true,
        regExpPatternsToRemove: [],
        name: newProjectName,
        namespace: namespace,
        namespaceCpp: namespaceCpp,
        languageIsCpp: language === 'cpp',
        mainComponentName: mainComponentName,
        // Visual Studio is very picky about the casing of the guids for projects, project references and the solution
        // https://www.bing.com/search?q=visual+studio+project+guid+casing&cvid=311a5ad7f9fc41089507b24600d23ee7&FORM=ANAB01&PC=U531
        // we therefore have to precariously use the right casing in the right place or risk building in VS breaking.
        projectGuidLower: `{${projectGuid.toLowerCase()}}`,
        projectGuidUpper: `{${projectGuid.toUpperCase()}}`,
        // packaging and signing variables:
        packageGuid: packageGuid,
        currentUser: currentUser,
        certificateThumbprint: certificateThumbprint,
        useExperimentalNuget: options.experimentalNuGetDependency,
        nuGetTestFeed: options.nuGetTestFeed,
        // cpp template variables
        useWinUI3: options.useWinUI3,
        useHermes: options.useHermes,
        xamlNamespace: xamlNamespace,
        xamlNamespaceCpp: xamlNamespaceCpp,
        cppNugetPackages: cppNugetPackages,
        // cs template variables
        csNugetPackages: csNugetPackages,
        // autolinking template variables
        autolinkPropertiesForProps: '',
        autolinkProjectReferencesForTargets: '',
        autolinkCsUsingNamespaces: '',
        autolinkCsReactPackageProviders: '',
        autolinkCppIncludes: '',
        autolinkCppPackageProviders: '\n    UNREFERENCED_PARAMETER(packageProviders);',
    };
    const commonMappings = projectType === 'app'
        ? [
            // app common mappings
            {
                from: path.join(srcRootPath, options.useDevMode
                    ? 'metro.devMode.config.js'
                    : 'metro.config.js'),
                to: 'metro.config.js',
            },
            {
                from: path.join(srcRootPath, '_gitignore'),
                to: path.join(windowsDir, '.gitignore'),
            },
            {
                from: path.join(srcRootPath, 'b_gitignore'),
                to: path.join(windowsDir, newProjectName, '.gitignore'),
            },
            {
                from: path.join(srcRootPath, 'index.windows.bundle'),
                to: path.join(windowsDir, newProjectName, bundleDir, 'index.windows.bundle'),
            },
            {
                from: path.join(srcPath, projDir, 'MyApp.sln'),
                to: path.join(windowsDir, newProjectName + '.sln'),
            },
        ]
        : [
            // lib common mappings
            {
                from: path.join(srcRootPath, '_gitignore'),
                to: path.join(windowsDir, '.gitignore'),
            },
            {
                from: path.join(srcPath, projDir, 'MyLib.sln'),
                to: path.join(windowsDir, newProjectName + '.sln'),
            },
        ];
    for (const mapping of commonMappings) {
        await generator_common_1.copyAndReplaceWithChangedCallback(mapping.from, destPath, mapping.to, templateVars, options.overwrite);
    }
    if (language === 'cs') {
        const csMappings = projectType === 'app'
            ? [
                // cs app mappings
                {
                    from: path.join(srcPath, projDir, 'MyApp.csproj'),
                    to: path.join(windowsDir, newProjectName, newProjectName + '.csproj'),
                },
            ]
            : [
                // cs lib mappings
                {
                    from: path.join(srcPath, projDir, 'MyLib.csproj'),
                    to: path.join(windowsDir, newProjectName, newProjectName + '.csproj'),
                },
            ];
        for (const mapping of csMappings) {
            await generator_common_1.copyAndReplaceWithChangedCallback(mapping.from, destPath, mapping.to, templateVars, options.overwrite);
        }
    }
    else {
        const cppMappings = projectType === 'app'
            ? [
                // cpp app mappings
                {
                    from: path.join(srcPath, projDir, 'MyApp.vcxproj'),
                    to: path.join(windowsDir, newProjectName, newProjectName + '.vcxproj'),
                },
                {
                    from: path.join(srcPath, projDir, 'MyApp.vcxproj.filters'),
                    to: path.join(windowsDir, newProjectName, newProjectName + '.vcxproj.filters'),
                },
                {
                    from: path.join(srcPath, projDir, 'packages.config'),
                    to: path.join(windowsDir, newProjectName, 'packages.config'),
                },
            ]
            : [
                // cpp lib mappings
                {
                    from: path.join(srcPath, projDir, 'MyLib.vcxproj'),
                    to: path.join(windowsDir, newProjectName, newProjectName + '.vcxproj'),
                },
                {
                    from: path.join(srcPath, projDir, 'MyLib.vcxproj.filters'),
                    to: path.join(windowsDir, newProjectName, newProjectName + '.vcxproj.filters'),
                },
                {
                    from: path.join(srcPath, projDir, 'MyLib.def'),
                    to: path.join(windowsDir, newProjectName, newProjectName + '.def'),
                },
                {
                    from: path.join(srcPath, projDir, 'packages.config'),
                    to: path.join(windowsDir, newProjectName, 'packages.config'),
                },
            ];
        for (const mapping of cppMappings) {
            await generator_common_1.copyAndReplaceWithChangedCallback(mapping.from, destPath, mapping.to, templateVars, options.overwrite);
        }
    }
    // shared proj
    if (fs.existsSync(path.join(sharedPath, projDir))) {
        const sharedProjMappings = [];
        sharedProjMappings.push({
            from: path.join(sharedPath, projDir, 'NuGet.Config'),
            to: path.join(windowsDir, 'NuGet.Config'),
        });
        if (fs.existsSync(path.join(sharedPath, projDir, 'ExperimentalFeatures.props'))) {
            sharedProjMappings.push({
                from: path.join(sharedPath, projDir, 'ExperimentalFeatures.props'),
                to: path.join(windowsDir, 'ExperimentalFeatures.props'),
            });
        }
        for (const mapping of sharedProjMappings) {
            await generator_common_1.copyAndReplaceWithChangedCallback(mapping.from, destPath, mapping.to, templateVars, options.overwrite);
        }
    }
    // shared assets
    if (fs.existsSync(path.join(sharedPath, 'assets'))) {
        await generator_common_1.copyAndReplaceAll(path.join(sharedPath, 'assets'), destPath, path.join(windowsDir, newProjectName, 'Assets'), templateVars, options.overwrite);
    }
    // shared src
    if (fs.existsSync(path.join(sharedPath, 'src'))) {
        await generator_common_1.copyAndReplaceAll(path.join(sharedPath, 'src'), destPath, path.join(windowsDir, newProjectName), templateVars, options.overwrite);
    }
    // src
    if (fs.existsSync(path.join(srcPath, 'src'))) {
        await generator_common_1.copyAndReplaceAll(path.join(srcPath, 'src'), destPath, path.join(windowsDir, newProjectName), templateVars, options.overwrite);
    }
    if (projectType === 'app') {
        console.log(chalk.white.bold('To run your app on UWP:'));
        console.log(chalk.white('   npx react-native run-windows'));
    }
}
exports.copyProjectTemplateAndReplace = copyProjectTemplateAndReplace;
function toCppNamespace(namespace) {
    return namespace.replace(/\./g, '::');
}
async function installScriptsAndDependencies(options) {
    var _a;
    const projectPackage = await package_utils_1.WritableNpmPackage.fromPath(process.cwd());
    if (!projectPackage) {
        throw new Error(`The current directory '${process.cwd()}' is not the root of an npm package`);
    }
    await projectPackage.mergeProps({
        scripts: { windows: 'react-native run-windows' },
    });
    const rnwPackage = await package_utils_1.findPackage('react-native-windows');
    if (!rnwPackage) {
        throw new Error('Could not locate the package for react-native-windows');
    }
    const rnPackage = await package_utils_1.findPackage('react-native');
    if (!rnPackage) {
        throw new Error('Could not locate the package for react-native');
    }
    const rnPeerDependency = rnwPackage.json.peerDependencies['react-native'];
    if (!semver.satisfies(rnPackage.json.version, rnPeerDependency) && ((_a = projectPackage.json.dependencies) === null || _a === void 0 ? void 0 : _a['react-native'])) {
        console.log(chalk.green('Installing a compatible version of react-native:'));
        console.log(chalk.white(`    ${rnPeerDependency}`));
        // Patch package.json to have proper react-native version and install
        await projectPackage.mergeProps({
            dependencies: { 'react-native': rnPeerDependency },
        });
        // Install dependencies using correct package manager
        const isYarn = fs.existsSync(path.join(process.cwd(), 'yarn.lock'));
        childProcess.execSync(isYarn ? 'yarn' : 'npm i', options.verbose ? { stdio: 'inherit' } : {});
    }
}
exports.installScriptsAndDependencies = installScriptsAndDependencies;
//# sourceMappingURL=index.js.map